/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * The token endpoint is used by the client to obtain an access token using a grant such as refresh token
         * @description Give a refresh token and get back both an access and refresh token. On initially creating, unlocking or recovering a wallet, store both the refresh and access tokens, the latter is valid for only 30 minutes (must be used for any authenticated call) while the former is for 4 hours (can only be used in the refresh request parameters). Use /token endpoint on a regular basis to get new access and refresh tokens, ideally before access token expiration to avoid authentication errors and in any case, before refresh token expiration. The newly issued tokens must be used in subsequent calls since operation invalidates previously issued tokens.
         *
         */
        post: operations["token"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/wallet/create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * create a new wallet
         * @description Give a filename (.jmdat must be included) and a password, create the wallet and get back the seedphrase for the newly persisted wallet file. The wallettype variable must be one of "sw" - segwit native, "sw-legacy" - segwit legacy or "sw-fb" - segwit native with fidelity bonds supported, the last of which is the default. Note that this operation cannot be performed when a wallet is already loaded (unlocked).
         */
        post: operations["createwallet"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/wallet/recover": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * recover a wallet from a seedphrase
         * @description Give a filename (.jmdat must be included), a wallettype, a seedphrase and a password, create the wallet for the newly persisted wallet file. The wallettype variable must be one of "sw" - segwit native, "sw-legacy" - segwit legacy or "sw-fb" - segwit native with fidelity bonds supported, the last of which is the default. The seedphrase must be a single string with words space-separated, and must conform to BIP39 (else 400 is returned). Note that this operation cannot be performed when a wallet is already loaded (unlocked).
         */
        post: operations["recoverwallet"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/wallet/{walletname}/unlock": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * decrypt an existing wallet
         * @description Give the password for the specified (existing) wallet file, and it will be decrypted ready for use. Note that this operation cannot be performed when another wallet is already loaded (unlocked).
         */
        post: operations["unlockwallet"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/wallet/{walletname}/lock": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * block access to a currently decrypted wallet
         * @description After this (authenticated) action, the wallet will not be readable or writeable.
         */
        get: operations["lockwallet"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/wallet/{walletname}/display": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * get detailed breakdown of wallet contents by account.
         * @description get detailed breakdown of wallet contents by account.
         */
        get: operations["displaywallet"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/session": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * get current status of backend
         * @description get whether a wallet is loaded and whether coinjoin/maker are happening. if an auth token is provided, which is optional, it will be validated.
         */
        get: operations["session"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/getinfo": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * get info on backend
         * @description get information about backend, including the version of Joinmarket running.
         */
        get: operations["version"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/wallet/all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * get current available wallets
         * @description get all wallet filenames in standard location as a list
         */
        get: operations["listwallets"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/wallet/yieldgen/report": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * get latest report on yield generating activity
         * @description Get list of coinjoins taken part in as maker (across all wallets). Data returned as list of strings, each one in the same comma separated format as found in yigen-statement.csv. Note that this returns all lines in the file, including the lines that are only present to represent the starting of a bot. Those lines contain the word Connected and can be thus discarded. The header line is also delivered and so can be ignored as per the client requirements.
         *
         */
        get: operations["yieldgenreport"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/wallet/{walletname}/address/new/{mixdepth}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * get a fresh address in the given account for depositing funds.
         * @description get a fresh address in the given account for depositing funds.
         */
        get: operations["getaddress"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/wallet/{walletname}/rescanblockchain/{blockheight}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Rescan the blockchain from a given blockheight
         * @description Use this operation on recovered wallets to re-sync the wallet
         */
        get: operations["rescanblockchain"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/wallet/{walletname}/address/timelock/new/{lockdate}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * get a fresh timelock address
         * @description get a new timelocked address, for depositing funds, to create a fidelity bond, which will automatically be used when the maker is started. specify the date in YYYY-mm as the last path parameter. Note that mixdepth is not specified as timelock addresses are always in mixdepth(account) zero.
         */
        get: operations["gettimelockaddress"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/wallet/{walletname}/utxos": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * list details of all utxos currently in the wallet.
         * @description list details of all utxos currently in the wallet.
         */
        get: operations["listutxos"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/wallet/{walletname}/taker/direct-send": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * create and broadcast a transaction (without coinjoin)
         * @description create and broadcast a transaction (without coinjoin)
         */
        post: operations["directsend"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/wallet/{walletname}/maker/start": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Start the yield generator service.
         * @description Start the yield generator service with the configuration settings specified in the POST request. Note that if fidelity bonds are enabled in the wallet, and a timelock address has been generated, and then funded, the fidelity bond will automatically be advertised without any specific configuration in this request. Note that if the wallet does not have confirmed coins, or another taker or maker coinjoin service is already running, the maker will not start.
         */
        post: operations["startmaker"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/wallet/{walletname}/maker/stop": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * stop the yield generator service
         * @description stop the yield generator service
         */
        get: operations["stopmaker"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/wallet/{walletname}/taker/coinjoin": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * initiate a coinjoin as taker
         * @description initiate a coinjoin as taker
         */
        post: operations["docoinjoin"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/wallet/{walletname}/taker/schedule": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * get the schedule that is currently running
         * @description Get the current transaction schedule if one is running.
         */
        get: operations["getschedule"];
        put?: never;
        /**
         * create and run a schedule of transactions
         * @description Creates and then starts a schedule of transactions.
         */
        post: operations["runschedule"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/wallet/{walletname}/taker/stop": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * stop a running coinjoin attempt
         * @description stop a running coinjoin attempt
         */
        get: operations["stopcoinjoin"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/wallet/{walletname}/configset": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * change a config variable
         * @description change a config variable (for the duration of this backend daemon process instance)
         */
        post: operations["configsetting"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/wallet/{walletname}/configget": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * get the value of a specific config setting
         * @description Get the value of a specific config setting. Note values are always returned as string.
         */
        post: operations["configget"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/wallet/{walletname}/freeze": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * freeze or unfreeze an individual utxo for spending
         * @description freeze or unfreeze an individual utxo for spending
         */
        post: operations["freeze"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/wallet/{walletname}/getseed": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * get the mnemonic recovery phrase with the optional passphrase
         * @description Get the mnemonic recovery phrase with the optional passphrase. Not the response is a sentence with few line breaks.
         */
        get: operations["getseed"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        FreezeRequest: {
            "utxo-string": string;
            freeze: boolean;
        };
        ConfigSetRequest: {
            section: string;
            field: string;
            value: string;
        };
        ConfigGetRequest: {
            section: string;
            field: string;
        };
        ConfigGetResponse: {
            configvalue: string;
        };
        ConfigSetResponse: Record<string, never>;
        FreezeResponse: Record<string, never>;
        DoCoinjoinRequest: {
            /** @example 0 */
            mixdepth: number;
            /** @example 100000000 */
            amount_sats: number;
            /** @example 9 */
            counterparties: number;
            /** @example bcrt1qujp2x2fv437493sm25gfjycns7d39exjnpptzw */
            destination: string;
            /**
             * @description Bitcoin miner fee to use for transaction. A number higher than 1000 is used as satoshi per kvB tx fee. The number lower than that uses the dynamic fee estimation of blockchain provider as confirmation target.
             * @example 6
             */
            txfee?: unknown;
        };
        TokenRequest: {
            grant_type: string;
            refresh_token: string;
        };
        TokenResponse: {
            token: string;
            token_type: string;
            expires_in: number;
            scope: string;
            refresh_token: string;
        };
        RunScheduleRequest: {
            destination_addresses?: string[];
            tumbler_options?: {
                addrcount?: number;
                minmakercount?: number;
                /** @example [
                 *       9,
                 *       1
                 *     ] */
                makercountrange?: number[];
                mixdepthcount?: number;
                mintxcount?: number;
                /** @example [
                 *       2,
                 *       1
                 *     ] */
                txcountparams?: number[];
                timelambda?: number;
                stage1_timelambda_increase?: number;
                liquiditywait?: number;
                waittime?: number;
                mixdepthsrc?: number;
                restart?: boolean;
                schedulefile?: string;
                mincjamount?: number;
                amtmixdepths?: number;
                rounding_chance?: number;
                /** @example [
                 *       55,
                 *       15,
                 *       25,
                 *       65,
                 *       40
                 *     ] */
                rounding_sigfig_weights?: number[];
            };
        };
        StartMakerRequest: {
            /** @example 0 */
            txfee: string;
            /** @example 5000 */
            cjfee_a: string;
            /** @example 0.00004 */
            cjfee_r: string;
            /** @example reloffer */
            ordertype: string;
            /** @example 8000000 */
            minsize: string;
        };
        /** @example bcrt1qujp2x2fv437493sm25gfjycns7d39exjnpptzw */
        GetAddressResponse: string;
        ListWalletsResponse: {
            wallets?: string[];
        };
        YieldGenReportResponse: string[];
        GetinfoResponse: {
            /** @example 0.9.10 */
            version: string;
        };
        RescanBlockchainResponse: {
            /** @example wallet.jmdat */
            walletname: string;
        };
        SessionResponse: {
            session: boolean;
            maker_running: boolean;
            coinjoin_in_process: boolean;
            schedule?: (string | number)[][];
            /** @example wallet.jmdat */
            wallet_name: string;
            offer_list?: {
                oid?: number;
                ordertype?: string;
                minsize?: number;
                maxsize?: number;
                txfee?: number;
                cjfee?: string;
            }[];
            nickname?: string;
            rescanning: boolean;
            block_height?: number;
        };
        ListUtxosResponse: {
            utxos?: {
                utxo?: string;
                address?: string;
                path?: string;
                label?: string;
                value?: number;
                tries?: number;
                tries_remaining?: number;
                external?: boolean;
                mixdepth?: number;
                confirmations?: number;
                frozen?: boolean;
            }[];
        };
        WalletDisplayResponse: {
            walletname: string;
            walletinfo: {
                wallet_name: string;
                total_balance: string;
                available_balance?: string;
                accounts: {
                    account?: string;
                    account_balance?: string;
                    available_balance?: string;
                    branches?: {
                        branch?: string;
                        balance?: string;
                        available_balance?: string;
                        entries?: {
                            hd_path?: string;
                            address?: string;
                            amount?: string;
                            available_balance?: string;
                            status?: string;
                            label?: string;
                            extradata?: string;
                        }[];
                    }[];
                }[];
            };
        };
        CreateWalletResponse: {
            /** @example wallet.jmdat */
            walletname: string;
            seedphrase: string;
            /** Format: byte */
            token: string;
            /** Format: byte */
            refresh_token: string;
        };
        UnlockWalletResponse: {
            /** @example wallet.jmdat */
            walletname: string;
            /** Format: byte */
            token: string;
            /** Format: byte */
            refresh_token: string;
        };
        DirectSendResponse: {
            txinfo: {
                hex?: string;
                inputs?: {
                    outpoint?: string;
                    scriptSig?: string;
                    nSequence?: number;
                    witness?: string;
                }[];
                outputs?: {
                    value_sats?: number;
                    scriptPubKey?: string;
                    address?: string;
                }[];
                txid?: string;
                nLockTime?: number;
                nVersion?: number;
            };
        };
        GetSeedResponse: {
            seedphrase: string;
        };
        GetScheduleResponse: {
            schedule: (string | number)[][];
        };
        LockWalletResponse: {
            /** @example wallet.jmdat */
            walletname: string;
            /** @example false */
            already_locked: boolean;
        };
        CreateWalletRequest: {
            /** @example wallet.jmdat */
            walletname: string;
            /**
             * Format: password
             * @example hunter2
             */
            password: string;
            /** @example sw-fb */
            wallettype: string;
        };
        RecoverWalletRequest: {
            /** @example wallet.jmdat */
            walletname: string;
            /**
             * Format: password
             * @example hunter2
             */
            password: string;
            /** @example sw-fb */
            wallettype: string;
            /** @example abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about */
            seedphrase: string;
        };
        UnlockWalletRequest: {
            /**
             * Format: password
             * @example hunter2
             */
            password: string;
        };
        DirectSendRequest: {
            /** @example 0 */
            mixdepth: number;
            /** @example 100000000 */
            amount_sats: number;
            /** @example bcrt1qu7k4dppungsqp95nwc7ansqs9m0z95h72j9mze */
            destination: string;
            /**
             * @description Bitcoin miner fee to use for transaction. A number higher than 1000 is used as satoshi per kvB tx fee. The number lower than that uses the dynamic fee estimation of blockchain provider as confirmation target.
             * @example 6
             */
            txfee?: number;
        };
        ErrorMessage: {
            message?: string;
            error_description?: string;
        };
    };
    responses: {
        /** @description transaction broadcast OK. */
        "DirectSend-200-Accepted": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["DirectSendResponse"];
            };
        };
        /** @description successful retrieval of utxo list */
        "ListUtxos-200-OK": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ListUtxosResponse"];
            };
        };
        /** @description successful retrieval of config value */
        "ConfigGet-200-OK": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ConfigGetResponse"];
            };
        };
        /** @description successful update of config value */
        "ConfigSet-200-OK": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ConfigSetResponse"];
            };
        };
        /** @description successful retrieval of new address */
        "GetAddress-200-OK": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GetAddressResponse"];
            };
        };
        /** @description successful response to listwallets */
        "ListWallets-200-OK": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ListWalletsResponse"];
            };
        };
        /** @description Access token obtained successfully */
        "Token-200-OK": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["TokenResponse"];
            };
        };
        /** @description successful heartbeat response */
        "Session-200-OK": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["SessionResponse"];
            };
        };
        /** @description successful Joinmarket getinfo response */
        "Getinfo-200-OK": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GetinfoResponse"];
            };
        };
        /** @description Blockchain rescan started successfully */
        "RescanBlockchain-200-OK": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["RescanBlockchainResponse"];
            };
        };
        /** @description wallet created successfully */
        "Create-201-OK": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["CreateWalletResponse"];
            };
        };
        /** @description wallet recovered successfully */
        "Recover-201-OK": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["CreateWalletResponse"];
            };
        };
        /** @description wallet unlocked successfully */
        "Unlock-200-OK": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["UnlockWalletResponse"];
            };
        };
        /** @description wallet display contents retrieved successfully. */
        "Display-200-OK": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["WalletDisplayResponse"];
            };
        };
        /** @description wallet locked successfully */
        "Lock-200-OK": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["LockWalletResponse"];
            };
        };
        /** @description seedphrase retrieved successfully */
        "GetSeed-200-OK": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GetSeedResponse"];
            };
        };
        /** @description freeze or unfreeze utxo action completed successfully */
        "Freeze-200-OK": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["FreezeResponse"];
            };
        };
        /** @description schedule started successfully */
        "RunSchedule-202-OK": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GetScheduleResponse"];
            };
        };
        /** @description schedule retrieved successfully */
        "GetSchedule-200-OK": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GetScheduleResponse"];
            };
        };
        /** @description get list of coinjoins taken part in as maker (across all wallets) */
        "YieldGenReport-200-OK": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["YieldGenReportResponse"];
            };
        };
        /** @description The request has been submitted successfully for processing, but the processing has not been completed. */
        "202-Accepted": {
            headers: {
                [name: string]: unknown;
            };
            content?: never;
        };
        /** @description Bad request format. */
        "400-BadRequest": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ErrorMessage"];
            };
        };
        /** @description Unable to authorise the credentials that were supplied. */
        "401-Unauthorized": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ErrorMessage"];
            };
        };
        /** @description Unable to complete request because object already exists. */
        "409-AlreadyExists": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ErrorMessage"];
            };
        };
        /** @description Unable to complete request because config settings are missing. */
        "409-NoConfig": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ErrorMessage"];
            };
        };
        /** @description Transaction failed to broadcast. */
        "409-TransactionFailed": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ErrorMessage"];
            };
        };
        /** @description Maker could not start without confirmed balance. */
        "409-No-Coins": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ErrorMessage"];
            };
        };
        /** @description Item not found. */
        "404-NotFound": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ErrorMessage"];
            };
        };
        /** @description The server is not ready to process the request. */
        "503-ServiceUnavailable": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ErrorMessage"];
            };
        };
    };
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    token: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description token refresh parameters */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["TokenRequest"];
            };
        };
        responses: {
            200: components["responses"]["Token-200-OK"];
            400: components["responses"]["400-BadRequest"];
        };
    };
    createwallet: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description wallet creation parameters */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CreateWalletRequest"];
            };
        };
        responses: {
            201: components["responses"]["Create-201-OK"];
            400: components["responses"]["400-BadRequest"];
            401: components["responses"]["401-Unauthorized"];
            409: components["responses"]["409-AlreadyExists"];
        };
    };
    recoverwallet: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description wallet recovery parameters */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["RecoverWalletRequest"];
            };
        };
        responses: {
            201: components["responses"]["Create-201-OK"];
            400: components["responses"]["400-BadRequest"];
            401: components["responses"]["401-Unauthorized"];
            409: components["responses"]["409-AlreadyExists"];
        };
    };
    unlockwallet: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of wallet including .jmdat */
                walletname: string;
            };
            cookie?: never;
        };
        /** @description wallet unlocking parameters */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UnlockWalletRequest"];
            };
        };
        responses: {
            200: components["responses"]["Unlock-200-OK"];
            400: components["responses"]["400-BadRequest"];
            401: components["responses"]["401-Unauthorized"];
            404: components["responses"]["404-NotFound"];
            409: components["responses"]["409-AlreadyExists"];
        };
    };
    lockwallet: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of wallet including .jmdat */
                walletname: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Lock-200-OK"];
            400: components["responses"]["400-BadRequest"];
        };
    };
    displaywallet: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of wallet including .jmdat */
                walletname: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Display-200-OK"];
            400: components["responses"]["400-BadRequest"];
            404: components["responses"]["404-NotFound"];
        };
    };
    session: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Session-200-OK"];
            404: components["responses"]["404-NotFound"];
        };
    };
    version: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Getinfo-200-OK"];
        };
    };
    listwallets: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ListWallets-200-OK"];
            404: components["responses"]["404-NotFound"];
        };
    };
    yieldgenreport: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["YieldGenReport-200-OK"];
            404: components["responses"]["404-NotFound"];
        };
    };
    getaddress: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of wallet including .jmdat */
                walletname: string;
                /** @description account or mixdepth to source the address from (0..4) */
                mixdepth: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GetAddress-200-OK"];
            400: components["responses"]["400-BadRequest"];
            404: components["responses"]["404-NotFound"];
        };
    };
    rescanblockchain: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of wallet including .jmdat */
                walletname: string;
                /** @description starting block height for the rescan */
                blockheight: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RescanBlockchain-200-OK"];
            400: components["responses"]["400-BadRequest"];
            404: components["responses"]["404-NotFound"];
        };
    };
    gettimelockaddress: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of wallet including .jmdat */
                walletname: string;
                /** @description month whose first day will be the end of the timelock, for this address. */
                lockdate: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GetAddress-200-OK"];
            400: components["responses"]["400-BadRequest"];
            404: components["responses"]["404-NotFound"];
        };
    };
    listutxos: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of wallet including .jmdat */
                walletname: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ListUtxos-200-OK"];
            400: components["responses"]["400-BadRequest"];
            404: components["responses"]["404-NotFound"];
        };
    };
    directsend: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of wallet including .jmdat */
                walletname: string;
            };
            cookie?: never;
        };
        /** @description transaction creation parameters */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["DirectSendRequest"];
            };
        };
        responses: {
            200: components["responses"]["DirectSend-200-Accepted"];
            400: components["responses"]["400-BadRequest"];
            404: components["responses"]["404-NotFound"];
            409: components["responses"]["409-TransactionFailed"];
        };
    };
    startmaker: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of wallet including .jmdat */
                walletname: string;
            };
            cookie?: never;
        };
        /** @description yield generator config parameters */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["StartMakerRequest"];
            };
        };
        responses: {
            202: components["responses"]["202-Accepted"];
            400: components["responses"]["400-BadRequest"];
            401: components["responses"]["401-Unauthorized"];
            404: components["responses"]["404-NotFound"];
            409: components["responses"]["409-No-Coins"];
            503: components["responses"]["503-ServiceUnavailable"];
        };
    };
    stopmaker: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of wallet including .jmdat */
                walletname: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            202: components["responses"]["202-Accepted"];
            400: components["responses"]["400-BadRequest"];
            401: components["responses"]["401-Unauthorized"];
            404: components["responses"]["404-NotFound"];
        };
    };
    docoinjoin: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of wallet including .jmdat */
                walletname: string;
            };
            cookie?: never;
        };
        /** @description taker side coinjoin parameters */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["DoCoinjoinRequest"];
            };
        };
        responses: {
            202: components["responses"]["202-Accepted"];
            400: components["responses"]["400-BadRequest"];
            401: components["responses"]["401-Unauthorized"];
            404: components["responses"]["404-NotFound"];
            409: components["responses"]["409-NoConfig"];
            503: components["responses"]["503-ServiceUnavailable"];
        };
    };
    getschedule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the wallet including .jmdat */
                walletname: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GetSchedule-200-OK"];
            400: components["responses"]["400-BadRequest"];
            404: components["responses"]["404-NotFound"];
        };
    };
    runschedule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of wallet including .jmdat */
                walletname: string;
            };
            cookie?: never;
        };
        /** @description taker side schedule parameters */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["RunScheduleRequest"];
            };
        };
        responses: {
            202: components["responses"]["RunSchedule-202-OK"];
            400: components["responses"]["400-BadRequest"];
            401: components["responses"]["401-Unauthorized"];
            404: components["responses"]["404-NotFound"];
            409: components["responses"]["409-NoConfig"];
            503: components["responses"]["503-ServiceUnavailable"];
        };
    };
    stopcoinjoin: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of wallet including .jmdat */
                walletname: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            202: components["responses"]["202-Accepted"];
            400: components["responses"]["400-BadRequest"];
            401: components["responses"]["401-Unauthorized"];
            404: components["responses"]["404-NotFound"];
        };
    };
    configsetting: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of wallet including .jmdat */
                walletname: string;
            };
            cookie?: never;
        };
        /** @description config editing parameters */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ConfigSetRequest"];
            };
        };
        responses: {
            200: components["responses"]["ConfigSet-200-OK"];
            400: components["responses"]["400-BadRequest"];
            409: components["responses"]["409-NoConfig"];
        };
    };
    configget: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of wallet including .jmdat */
                walletname: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ConfigGetRequest"];
            };
        };
        responses: {
            200: components["responses"]["ConfigGet-200-OK"];
            400: components["responses"]["400-BadRequest"];
            409: components["responses"]["409-NoConfig"];
        };
    };
    freeze: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of wallet including .jmdat */
                walletname: string;
            };
            cookie?: never;
        };
        /** @description utxo string and freeze toggle as boolean */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["FreezeRequest"];
            };
        };
        responses: {
            200: components["responses"]["Freeze-200-OK"];
            400: components["responses"]["400-BadRequest"];
        };
    };
    getseed: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the wallet including .jmdat */
                walletname: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GetSeed-200-OK"];
            400: components["responses"]["400-BadRequest"];
        };
    };
}
